# Design Patterns in Java

This repository contains code and UML structure diagrams for various design patterns implemented in Java.

## Creational Patterns

Creational patterns focus on the process of object creation.

### Singleton Pattern

Intent: Ensure a class has only one instance, and provide a global point of access to it.

### Factory Method Pattern

Intent: Define an interface for creating objects, but let subclasses decide which classes to instantiate. Factory Method lets a class defer instantiation to subclasses.

### Abstract Factory Pattern

Intent: Provide an interface for creating families of related or dependent objects without specifying their concrete classes.

### Builder Pattern

Intent: Separate the construction of a complex object from its representation, allowing the same construction process to create various representations.

### Prototype Pattern

Intent: Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.

## Structural Patterns

Structural patterns focus on the composition of classes and objects.

### Adapter Pattern

Intent: Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.

### Bridge Pattern

Intent: Decouple an abstraction from its implementation so that the two can vary independently.

### Composite Pattern

Intent: Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.

### Decorator Pattern

Intent: Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.

### Facade Pattern

Intent: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.

### Flyweight Pattern

Intent: Use sharing to support large numbers of fine-grained objects efficiently.

### Proxy Pattern

Intent: Provide a surrogate or placeholder for another object to control access to it.

## Behavioral Patterns

Behavioral patterns focus on communication between objects and how they operate together.

### Chain of Responsibility Pattern

Intent: Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.

### Command Pattern

Intent: Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.

### Interpreter Pattern

Intent: Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.

### Iterator Pattern

Intent: Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

### Observer Pattern

Intent: Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

### State Pattern

Intent: Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.

### Strategy Pattern

Intent: Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.


❤❤💛💛❤❤💛💛❤❤💛💛❤❤💛💛❤❤

Thank You, and Make Sure To Give This Repo a Like and Fork This For Usage. And Dont Forget to Follow Me on Github